# 2.1 — State Model

## 1. What’s in State vs Not

- **In state file (`terraform.tfstate`):**

  - **Resources** → mapping between Terraform resource addresses and real infra (IDs, ARNs, attributes).
  - **Outputs** → values exposed from modules.
  - **Dependencies** → the graph of resources.
  - **Meta info** → provider versions, lineage, serials, checksums.

- **Not in state:**

  - Input variable values (unless written as outputs).
  - Provider credentials (AWS keys, etc.).
  - Local-only values (`locals`).

Shortcut: _“State tracks real infra (resources, IDs, outputs), not secrets or inputs.”_

## 2. Refresh Mechanics

- On each `terraform plan`/`apply`:

  - Terraform **refreshes state in memory** by re-querying the provider.
  - Unknown values (`(known after apply)`) remain placeholders until the resource is created.

- Example:

  - Before creation → EC2 instance `public_ip` = `(known after apply)`.
  - After apply → filled with actual IP in state.

Shortcut: _“Refresh = pull current values from cloud → update plan → update state after apply.”_

## 3. State Drift & Why It Happens

- **State Drift** = when real infra ≠ Terraform state.
- Causes:

  - Someone changed cloud infra manually (console, CLI).
  - Automation outside Terraform modified resources.
  - Provider bug or failed apply left state inconsistent.

- Detection:

  - `terraform plan` will show unexpected changes (differences).
  - `terraform plan -refresh-only` audits infra vs state without proposing modifications.
