# 2.4 — Consuming Remote State

## 1. `terraform_remote_state` Data Source

- A special **data source** that lets one Terraform project (stack) **read the outputs** of another project’s state file.
- Think of it as: _“import values from another stack’s outputs, instead of re-computing or hardcoding them.”_

### **Basic Example (S3 backend)**

Suppose you have a **network stack** that outputs a VPC ID and subnet IDs.

**network/outputs.tf**

```hcl
output "vpc_id" {
  value = aws_vpc.main.id
}
output "subnet_ids" {
  value = aws_subnet.public[*].id
}
```

**app/main.tf** (consumer stack)

```hcl
data "terraform_remote_state" "network" {
  backend = "s3"
  config = {
    bucket = "my-terraform-states"
    key    = "network/prod/terraform.tfstate"
    region = "ap-south-1"
  }
}

resource "aws_instance" "web" {
  ami           = "ami-12345"
  instance_type = "t3.micro"
  subnet_id     = data.terraform_remote_state.network.outputs.subnet_ids[0]
}
```

Now the **app stack** uses the **VPC + subnet outputs** from the **network stack**.

### **Backend Variations**

Works with any supported backend (`s3`, `azurerm`, `gcs`, `remote`/Terraform Cloud).
Example for Terraform Cloud:

```hcl
data "terraform_remote_state" "network" {
  backend = "remote"
  config = {
    organization = "faizan-org"
    workspaces = {
      name = "network-prod"
    }
  }
}
```

### **Best Practices**

- Only expose **stable outputs** — avoid changing or renaming outputs unless versioning downstream.
- Use this for **Terraform-managed infra handoff** (e.g., VPC IDs, DB connection strings).
- Don’t overuse: for resources outside Terraform, prefer **provider data sources**.
- In large orgs, outputs are often treated like an **API contract** between stacks.

### **Pros / Cons**

✅ Pros:

- Deterministic (always gets the same values Terraform created).
- Explicit — avoids “guessing” via provider lookups.

❌ Cons:

- Tight coupling → changes in one stack can break consumers.
- Harder to manage versioning if multiple stacks depend on the same outputs.

## 2. Cross-Stack Outputs vs Provider Data Sources

- **Cross-stack outputs (`terraform_remote_state`)**

  - Explicitly controlled handoff of values.
  - Guarantees you get the exact resource IDs your infra created.
  - Tightens dependency between stacks.

- **Provider data sources**

  - Query live infra instead of pulling from another state.
  - Example:

    ```hcl
    data "aws_vpc" "default" {
      default = true
    }
    ```

  - Looser coupling, but less predictable (infra may change).

**Trade-off:**

- Use **remote state outputs** when infra is Terraform-managed and you want strong guarantees.
- Use **provider data sources** when infra may exist outside Terraform or needs discovery.

### 3. Versioning & Coupling Concerns

- **Coupling issue:**

  - If Stack A changes outputs, Stack B may break.
  - E.g., renaming `subnet_id` output → consumers fail.

- **Versioning patterns:**

  - Lock stacks together via Git version tags (e.g., `network` v1.2 → consumed by `app`).
  - Some orgs put outputs behind a private module or registry to stabilize interfaces.
  - Use **naming conventions** and avoid deleting/renaming outputs carelessly.
