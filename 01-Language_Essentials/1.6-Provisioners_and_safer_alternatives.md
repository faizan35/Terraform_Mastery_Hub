# 1.6 — Provisioners (last resort) & Safer Alternatives

## **1. What are Provisioners?**

- Special blocks (`local-exec`, `remote-exec`) that run **scripts/commands** after a resource is created.
- Examples:

  ```hcl
  resource "aws_instance" "web" {
    ami           = "ami-12345"
    instance_type = "t3.micro"

    provisioner "remote-exec" {
      inline = [
        "sudo apt update -y",
        "sudo apt install nginx -y"
      ]
    }
  }
  ```

- **local-exec** → runs on the machine where Terraform runs.
- **remote-exec** → runs inside the created resource via SSH/WinRM.

### **2. Why Provisioners Are Brittle**

- Hard to guarantee ordering (scripts may run before the infra is fully ready).
- Failures don’t always stop Terraform → can leave infra half-configured.
- Non-idempotent → running again may break (unlike declarative resources).
- Harder to debug in CI/CD pipelines.

### **3. Safer Alternatives**

- **User data / cloud-init** (for servers):

  - Pass startup scripts via EC2 `user_data` or cloud-init.
  - Cloud takes care of running scripts reliably on boot.

  ```hcl
  resource "aws_instance" "web" {
    ami           = "ami-12345"
    instance_type = "t3.micro"
    user_data     = file("${path.module}/userdata.sh")
  }
  ```

- **Pre-baked images**:

  - Use Packer or AMIs/VM images with software pre-installed.
  - Faster, more reliable deployments.

- **Config management tools**:

  - Ansible, Chef, Puppet, Salt → better suited for in-VM configuration.

### **4. Event Hooks (Alternatives Outside Terraform)**

- Instead of Terraform running scripts:

  - CI/CD pipelines (Jenkins, GitHub Actions, Azure DevOps) can trigger setup steps **after apply**.
  - Webhooks can notify external systems when infra changes.
  - Cloud-native solutions (e.g., AWS Lambda triggered on EC2 launch).
