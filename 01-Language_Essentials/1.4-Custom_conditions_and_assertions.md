# 1.4 — Custom Conditions & Assertions

## 1. Preconditions & Postconditions

- **What they are:** Assertions you attach to a resource or output.
- **Precondition** → Must be true **before** resource is created/updated.
- **Postcondition** → Must be true **after** resource is created.
- **Example:**

  ```hcl
  resource "aws_instance" "web" {
    ami           = var.ami_id
    instance_type = var.instance_type

    lifecycle {
      precondition {
        condition     = can(regex("^ami-", var.ami_id))
        error_message = "AMI ID must start with ami-"
      }

      postcondition {
        condition     = self.public_ip != ""
        error_message = "Instance must have a public IP assigned"
      }
    }
  }
  ```

- **Use case:** Catch invalid inputs early, enforce runtime expectations.

### 2. `check` Blocks

- **What they are:** Standalone assertions, not tied to a single resource.
- **Purpose:** Enforce guardrails across resources, beyond just type checks.
- **Example:**

  ```hcl
  check "only_prod_in_ap_south_1" {
    assert {
      condition     = var.env != "prod" || var.region == "ap-south-1"
      error_message = "Production must only run in ap-south-1 region."
    }
  }
  ```

- **Where to use:**

  - Policy-like checks in code (instead of Sentinel).
  - Enforcing naming standards, tag presence, region restrictions, etc.

- **Shape:** Always has one or more `assert` blocks inside.

### 3. User-Friendly Failure Messages

- **Why:** Default Terraform errors can be cryptic.
- **Best practice:** Write clear, actionable messages in assertions.
- **Examples:**

  - Bad: `"condition failed"`
  - Good: `"Instance type must be t3.* for cost optimization"`
  - Good: `"AMI ID invalid: must start with ami-"`
