# 1.2 — Meta-arguments

## 1. `count` vs `for_each`

Both are for **creating multiple instances** of a resource, but with different trade-offs.

#### `count`

- Index-based, creates _N_ copies.
- Example:

  ```hcl
  resource "aws_instance" "web" {
    count = 3
    ami   = "ami-12345"
    instance_type = "t3.micro"
    tags = { Name = "web-${count.index}" }
  }
  ```

- Creates `web[0]`, `web[1]`, `web[2]`.
- Keys are numeric indexes — if order changes, resources may be destroyed/recreated.

#### `for_each`

- Map or set-based, creates copies with **stable keys**.
- Example:

  ```hcl
  resource "aws_instance" "web" {
    for_each = {
      dev = "t3.micro"
      prod = "t3.medium"
    }
    ami           = "ami-12345"
    instance_type = each.value
    tags = { Name = each.key }
  }
  ```

- Resources are `web["dev"]` and `web["prod"]`.
- Keys don’t shift if you add/remove items → safer for long-term.

**Migration Pattern:**

- Moving from `count` → `for_each` requires `terraform state mv` to avoid resource replacement.
- Example:

  ```bash
  terraform state mv aws_instance.web[0] aws_instance.web["dev"]
  ```

#### `terraform state mv` — What it does

- **Moves or renames a resource address in the state file.**
- Does **not** touch the real infrastructure.
- Prevents Terraform from thinking it has to destroy and recreate the resource when the config changes.

### 2. `depends_on` and Hidden Dependencies

- Terraform usually detects dependencies automatically when you reference attributes.

  ```hcl
  subnet_id = aws_subnet.example.id   # implicit dependency
  ```

- But sometimes dependencies are _hidden_ (not obvious in code).
  Example: a provisioner running a script that requires a network gateway first.
- Use `depends_on` to enforce ordering:

  ```hcl
  resource "aws_instance" "web" {
    depends_on = [aws_internet_gateway.gw]
  }
  ```

- Best practice: **avoid unless necessary**; rely on implicit dependencies where possible.

## 3. `lifecycle` Block

### **`create_before_destroy`**

- **What it does:**
  Creates the new resource first, then deletes the old one.
- **Why:**
  Prevents downtime (e.g., rolling out a new Auto Scaling Group or replacing a load balancer).
- **Default behavior without it:**
  Destroy → Create (risk of downtime).
- **Pitfall:**
  May fail if the provider enforces uniqueness (e.g., unique bucket names in S3).

### **`prevent_destroy`**

- **What it does:**
  Protects critical resources (like a production DB) from being destroyed accidentally.
- **If `terraform destroy` is run:**
  Terraform errors out instead of deleting.
- **Use case:**
  Production databases, IAM roles, VPCs.
- **Pitfall:**
  Can block _intentional_ destroys too — you need to remove the flag before deleting.

### **`ignore_changes`**

- **What it does:**
  Ignores drift for specified attributes (Terraform won’t plan updates for them).
- **Use case examples:**

  - Auto Scaling groups → `desired_capacity` might change dynamically at runtime.
  - Tags added automatically by a cloud provider.

- **Pitfall:**
  Can hide real drift — use carefully, only for fields known to be managed outside Terraform.

### Quick Example

```hcl
resource "aws_autoscaling_group" "example" {
  name                 = "asg-example"
  desired_capacity     = 2
  max_size             = 5
  min_size             = 1

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
    ignore_changes        = [desired_capacity]
  }
}
```
