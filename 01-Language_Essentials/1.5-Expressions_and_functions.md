# 1.5 — Expressions & Functions

## 1. Collection Types & Iteration

- **Collections:** `list`, `map`, `set`, `object`, `tuple`.

- **For expressions:** Transform one collection into another.

  ```hcl
  variable "names" { default = ["dev", "staging", "prod"] }

  output "tags" {
    value = { for n in var.names : n => "project-${n}" }
  }
  ```

  → `{"dev"="project-dev", "staging"="project-staging", "prod"="project-prod"}`

- **Splat expressions (`[*]`):** Extract a field from multiple resources.

  ```hcl
  aws_instance.web[*].public_ip
  ```

  → Returns a list of public IPs for all `web` instances.

## 2. Handy Built-in Functions

### **`coalesce`**

- **What it does:** Returns the first value in a list of arguments that isn’t `null` or empty.
- **Use case:** Provide fallback values when a variable may not be set.
- **Example:**

  ```hcl
  variable "bucket_name" {
    default = null
  }

  output "chosen_bucket" {
    value = coalesce(var.bucket_name, "default-bucket")
  }
  ```

  If `bucket_name` is not set → output = `"default-bucket"`.

### **`try`**

- **What it does:** Tries to evaluate an expression; if it fails, it falls back to the next value.
- **Use case:** Safer handling of optional/unknown values (instead of crashing).
- **Example:**

  ```hcl
  output "instance_ip" {
    value = try(aws_instance.web[0].public_ip, "not yet created")
  }
  ```

  If the instance doesn’t exist yet → output = `"not yet created"`.

## 3. `dynamic` Blocks

- A way to **generate nested blocks dynamically** inside a resource.
- Useful when the number of sub-blocks depends on variables or inputs.

### **Why we need it**

Normally, nested blocks in Terraform must be hardcoded:

```hcl
resource "aws_security_group" "web" {
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

This works — but if you have many ports, it’s repetitive.

### **How `dynamic` solves it**

```hcl
variable "allowed_ports" {
  default = [80, 443]
}

resource "aws_security_group" "web" {
  name = "web-sg"

  dynamic "ingress" {
    for_each = var.allowed_ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}
```

Terraform will expand this into multiple `ingress {}` blocks automatically.

## 4. Templates & Encoding

### **1. HEREDOC Strings**

- Multi-line string directly inside your `.tf` file.
- Syntax:

  ```hcl
  user_data = <<-EOT
    #!/bin/bash
    echo "Hello World" > /var/www/html/index.html
  EOT
  ```

- **Use case:** Quick inline scripts (user_data, small configs).
- **Limitation:** Gets messy for big scripts or JSON policies.

### **2. `templatefile` Function**

- Loads an external file and injects variables into it.
- Syntax:

  ```hcl
  user_data = templatefile("${path.module}/userdata.sh", {
    env = var.env
    app = var.app_name
  })
  ```

- **Why better than HEREDOC?**

  - Keeps `.tf` code clean.
  - Reusable templates.
  - Easier for large scripts (bash, YAML, JSON).

### **3. JSON & YAML Encoding Helpers**

- **`jsonencode()`** → Converts Terraform values into JSON.

  ```hcl
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action   = ["s3:GetObject"]
      Effect   = "Allow"
      Resource = "*"
    }]
  })
  ```

  → Produces valid JSON for IAM policy.

- **`jsondecode()`** / **`yamldecode()`** → Parse JSON/YAML strings into Terraform values.

  ```hcl
  locals {
    data = jsondecode(file("${path.module}/config.json"))
  }
  output "db_user" {
    value = local.data.db.username
  }
  ```

### **When to Use What**

- **HEREDOC** → Inline, small configs/scripts.
- **templatefile()** → Large scripts or policies stored separately.
- **jsonencode()** → Generate JSON from HCL values (IAM, K8s manifests).
- **jsondecode()/yamldecode()** → Import external JSON/YAML configs into Terraform logic.

## 5. Provider-Defined Functions

- Most Terraform functions (like `merge()`, `lookup()`, `coalesce()`) are **built into Terraform itself**.
- But some **providers** (e.g., AWS, Azure, GCP) also expose **special helper functions** for working with their resources.
- These make configurations more **dynamic and less error-prone**.

### **Examples**

#### 1. AWS – `cidrsubnet()`

- Helps calculate subnet CIDRs from a base VPC CIDR.
- Example:

  ```hcl
  variable "vpc_cidr" { default = "10.0.0.0/16" }

  output "subnet1" {
    value = cidrsubnet(var.vpc_cidr, 4, 0) # → 10.0.0.0/20
  }

  output "subnet2" {
    value = cidrsubnet(var.vpc_cidr, 4, 1) # → 10.0.16.0/20
  }
  ```

- **Why useful:** avoids manual subnet math.

#### 2. Azure – `cidrhost()`

- Picks a specific host IP inside a subnet.

  ```hcl
  output "gateway_ip" {
    value = cidrhost("10.0.0.0/24", 1) # → 10.0.0.1
  }
  ```

#### 3. Kubernetes Provider Functions

- Some providers let you encode/decode configs inline.
- Example:

  ```hcl
  yamlencode({
    apiVersion = "v1"
    kind       = "ConfigMap"
    metadata = {
      name = "example"
    }
    data = {
      key = "value"
    }
  })
  ```

- Generates valid YAML for Kubernetes manifests.
