# 1.1 — Resources & Data Sources

## **1. Arguments vs Attributes**

- **Arguments** = things **you set** in your `.tf` code.
  Example:

  ```hcl
  resource "aws_instance" "web" {
    instance_type = "t3.micro"   # argument
    ami           = "ami-12345"  # argument
  }
  ```

- **Attributes** = values Terraform **reads back** from the provider after creation.
  Example:

  - `public_ip` → assigned by AWS after the instance launches.
  - You can reference it later like `aws_instance.web.public_ip`.

**Key point:**

- Arguments = inputs (you provide).
- Attributes = outputs (provider fills in).

## **2. Computed Values & Unknowns**

- **Computed values** = attributes you don’t know until apply.

  - Example: `public_ip` of an EC2 → unknown until created.

- Terraform shows these as `(known after apply)` in the plan.

**Unknowns**:

- During plan, Terraform can’t always know future values.
- That’s why dependency ordering matters (e.g., subnet ID generated in one resource, needed in another).

## **3. Data Sources**

- Data sources = **read-only lookups**.
- Example:

  ```hcl
  data "aws_ami" "ubuntu" {
    most_recent = true
    owners      = ["099720109477"] # Canonical
    filter {
      name   = "name"
      values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-*"]
    }
  }

  resource "aws_instance" "web" {
    ami           = data.aws_ami.ubuntu.id
    instance_type = "t3.micro"
  }
  ```

- Here, the instance uses the **latest Ubuntu AMI** found via a data source.

**Pitfalls:**

- Data sources query live APIs → results can change (non-deterministic).
- Can cause drift if the “latest” image updates between runs.
- Best practice: pin to stable versions whenever possible.

## **4. Inter-Resource References**

- You can connect resources together by referencing attributes.
  Example:

  ```hcl
  resource "aws_security_group" "web_sg" {
    name = "web-sg"
  }

  resource "aws_instance" "web" {
    ami           = "ami-12345"
    instance_type = "t3.micro"
    vpc_security_group_ids = [aws_security_group.web_sg.id]
  }
  ```

- Here, the instance depends on the SG.

### **Explicit vs Implicit Dependencies**

- **Implicit**: Terraform auto-detects dependency if you reference another resource’s attribute.
- **Explicit**: Use `depends_on` when Terraform can’t infer it.

  ```hcl
  resource "aws_instance" "web" {
    depends_on = [aws_security_group.web_sg]
    # ensures SG is created first
  }
  ```

## Interview Cheat Lines

- _“Arguments are inputs I set; attributes are outputs Terraform gets back from the provider.”_
- _“Data sources are read-only lookups; the tricky part is they can cause non-deterministic results if the source changes.”_
- _“Dependencies are usually implicit via references, but `depends_on` forces explicit ordering when Terraform can’t infer it.”_
