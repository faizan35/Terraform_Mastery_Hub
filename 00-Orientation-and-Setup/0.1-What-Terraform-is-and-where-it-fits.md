# Module 0.1 — What Terraform is & where it fits

## 1) IaC vs Configuration Management (CM) — plus declarative DAG, desired state, idempotence

- **IaC (Infrastructure as Code):** You _declare_ the infrastructure you want (VPCs, VNets, subnets, IAM, DNS, etc.) in code and let a tool provision/change it. Benefits: repeatable, versioned, reviewable. Terraform is an IaC tool.

- **CM (Configuration Management):** Focuses on _configuring software on machines_ (packages, files, services). Tools like Ansible/Chef/Puppet traditionally excel here and can complement IaC. (Good mental model: IaC builds the servers; CM configures what runs on them.)

- **Declarative DAG:** Terraform computes a dependency **graph** between resources and walks it to create/update/destroy in the right order; you can even render the graph with `terraform graph`.

- **Desired state & idempotence (practitioner view):** Your config describes the _end state_; repeated `apply` runs converge to it (no change if nothing drifted). Plan shows the diff first; apply executes it.

## 2) Terraform building blocks

1. **Providers = Plug-ins**

   - Think of providers like _drivers_.
   - It exposes resource/data types for a platform (AWS/Azure/GCP/K8s/SaaS).
   - AWS provider lets Terraform talk to AWS, Azure provider for Azure, etc.
   - Without the right driver, Terraform can’t create anything.

2. **Resources = Things you build**

   - Example: `aws_instance`, `azurerm_storage_account`.
   - These are the _actual things Terraform creates, updates, or destroys_.
   - **CRUD** (Create, Read, Update, Delete).

3. **Data sources = Read-only helpers**

   - They _look up existing stuff_ but don’t create/change it.
   - Example: fetch the latest AMI ID in AWS.
   - Think: _“Give me info, don’t touch it.”_

4. **Modules = Lego sets**

   - A module is a ready-made _package of resources_.
   - Instead of writing 50 lines to build a VPC, just use the “VPC module.”
   - You can reuse them in many projects.

5. **Plan vs Apply = Dry run vs Real run**

   - `terraform plan` → “Show me what will happen.” (safe preview)
   - `terraform apply` → “Actually do it.” (and it runs plan first if you didn’t).
   - Easy trick: **Plan = Proposal, Apply = Action.**

## 3) State, drift, refresh, CRUD lifecycle

### 1. **State = Terraform’s memory book**

- Terraform keeps a **map**: “this resource block → that real cloud object.”
- Without it, Terraform won’t know if `aws_instance.web` is your VM or a stranger’s.
- It also caches details so plans are faster.
- **Rule of thumb:** Store state remotely (S3, Azure Blob, Terraform Cloud) so teams don’t lose/overwrite it.

### 2. **Drift = Reality vs Terraform’s memory**

- Drift happens when **someone changes the cloud directly** (e.g., manual console edit).
- Terraform thinks one thing (from state) but reality is different.

  **ok someone changes the cloud directly, so how will terraform handle it.?**

- Terraform config: EC2 instance with tag `Name = web1`.
- You go into AWS console and change it to `Name = web2`.

  **What happens next?**

  1.  **State is now outdated**

  - Terraform’s state file still says `"Name" = "web1"`.
  - But real AWS says `"Name" = "web2"`.
  - → This mismatch = **drift**.

  2.  **Next `terraform plan`**

  - Terraform _refreshes_ state in-memory by asking AWS:
    “Hey EC2, what’s your current name?” → gets `web2`.
  - Then compares refreshed state with config (which still says `web1`).

  **Result in plan:**

  ```
  ~ tag.Name: "web2" → "web1"
  ```

  (\~ = update in-place)

  3.  **If you run `terraform apply`**

  - Terraform will reconcile by changing it **back to your config** (`web1`), unless you update the config file to match reality.

### 3. **Refresh = Double-check reality**

- When you `plan` or `apply`, Terraform asks the cloud: “Hey, what’s the _actual_ state now?” and updates its in-memory view.

- If there’s a mismatch → you’ll see drift in the plan.

- Special case: **`terraform plan -refresh-only`** → Just check what’s drifted, no changes.
  (This replaced the old `terraform refresh` command.)

### 4. **CRUD Lifecycle (how providers work under the hood)**

- Every resource in Terraform is basically:

  - **C**reate (make it new)
  - **R**ead (check if it exists & what’s inside)
  - **U**pdate (modify in place)
  - **D**elete (remove it)

- Plan works because providers tell Terraform: “If you change this field → I’ll run Update; if not possible → I’ll Destroy+Recreate.”

## 4) When to choose Terraform vs ARM/Bicep/CloudFormation/Pulumi

- **Terraform:** _Cloud-agnostic,_ huge provider ecosystem; great when you need one tool/one language across clouds and SaaS.
- **Azure Bicep:** _Azure-native_ DSL over ARM. Excellent if you’re Azure-only and want 1st-party parity/diagnostics.
- **AWS CloudFormation:** _AWS-native_ IaC with stack semantics; tight service integration and registry. Best if you’re deep, AWS-only.
- **Pulumi:** General-purpose languages (TS/Python/Go/C#) and multi-cloud. Consider if you want imperative language ergonomics or to reuse app tooling.

**Rule of thumb (say this):** “Azure-only? Bicep. AWS-only? CloudFormation. Polycloud or lots of SaaS/K8s? Terraform. Want IaC in a general-purpose language? Pulumi.”
