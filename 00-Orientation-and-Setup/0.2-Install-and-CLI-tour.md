# 0.2 — Install & CLI tour

## Install, verify, and enable tab-completion

- Install from the official instructions for your OS (brew/apt/dnf/Chocolatey/manual). Then verify:
  `terraform version` (prints CLI version, platform, and providers).
- Enable tab-completion (bash/zsh):
  `terraform -install-autocomplete` → restart your shell. To remove: `terraform -uninstall-autocomplete`.

## Everyday commands (one-liners)

## `terraform init`

- `-upgrade` → Update providers/modules to the latest allowed versions.
- `-reconfigure` → Ignore existing `.terraform/` settings and start fresh (useful when backend config changes).
- `-backend-config="key=value"` → Override backend settings on the fly.

## `terraform fmt`

- `-recursive` → Format all subdirectories (modules too).
- `-check` → Exit non-zero if formatting is needed (CI/CD pipelines).
- `-diff` → Show what formatting would change.

## `terraform validate`

- No major flags (simple).
- Tip: combine with `-json` if you want structured output for automation.

## `terraform plan`

- `-out=tfplan` → Save the plan to apply later (safe practice in pipelines).
- `-var="key=value"` → Override a variable directly from CLI.
- `-var-file=dev.tfvars` → Load variables from a file.
- `-target=resource.addr` → Plan only a specific resource (use cautiously).
- `-refresh=false` → Skip state refresh (rare; useful for speed in some CI cases).
- `-detailed-exitcode` → Exit codes:

  - `0 = no changes`
  - `2 = changes present`
  - `1 = error`

## `terraform apply`

- `tfplan` (file) → Apply a saved plan from above.
- `-auto-approve` → Skip confirmation prompt (only in automation).
- Same `-var` and `-var-file` options as `plan`.

## `terraform destroy`

- `-auto-approve` → Skip “Are you sure?” prompt.
- `-target=resource.addr` → Destroy specific resource(s) only.

## `terraform show`

- `terraform show -json` → Machine-readable output (JSON).
- `terraform show tfplan` → Show a saved plan file in human-readable form.

## `-chdir`, workdir hygiene, and the two special files

- Run from elsewhere without `cd`: `terraform -chdir=envs/dev plan`.
- Terraform creates a hidden `.terraform/` folder (providers/modules cache, workspace info, backend notes). Don’t commit it.
- Commit `.terraform.lock.hcl` (provider versions & checksums). It’s created/updated by `init`; keep it in VCS.

## Useful environment variables (debugging & caching)

### Debugging

- `TF_LOG=trace` → Show detailed logs (to stderr).

  - **Levels:**
  - **TRACE** → Show everything, down to internal functions (deep debugging).
  - **DEBUG** → Show provider/API calls (troubleshooting).
  - **INFO** → Show normal high-level workflow (default clarity).
  - **WARN** → Show only warnings (deprecations, risky ops).
  - **ERROR** → Show only errors (failures).

- `TF_LOG_PATH=./terraform.log` → Write logs to a file.
- Turn off logs with `TF_LOG=off`.

### Provider Plugin Caching

Here’s that section made crisp and practical:

### Provider Plugin Caching

- **`TF_PLUGIN_CACHE_DIR=~/.terraform.d/plugin-cache`**

  - Caches downloaded provider plugins locally.
  - Saves bandwidth and speeds up `terraform init` in repeated runs.
  - Especially useful in CI/CD where the cache directory is persisted between jobs.

- **Alternative: CLI config file**

  - Instead of setting env vars, you can add to `~/.terraformrc` (Linux/Mac) or `%APPDATA%\terraform.rc` (Windows):

    ```hcl
    plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"
    ```

### Non-Interactive / CI Use

- **`TF_IN_AUTOMATION=1`**

  - Tells Terraform it’s running inside automation.
  - Makes output machine-friendly and disables some interactive prompts.
  - Useful in CI pipelines where you don’t want Terraform waiting for user input.

- **`TF_CLI_ARGS_*`**

  - Lets you set default flags for commands globally.
  - Example:

    ```bash
    TF_CLI_ARGS_plan="-parallelism=5"
    ```

    This means every `terraform plan` will automatically use `-parallelism=5` unless overridden.

### Exit Codes & CI Tips

#### **`terraform plan -detailed-exitcode`**

- Exit codes:

  - `0` = Success, no changes.
  - `1` = Error.
  - `2` = Success, but changes present.

- In CI, you can use this to decide whether to block a PR or trigger an approval workflow.

##### How.?

- **Exit 0** → No drift, no new infra → pipeline passes, merge can be auto-approved.
- **Exit 2** → Changes detected → block merge or mark PR as “needs review/approval.”
- **Exit 1** → Plan error → pipeline fails immediately.

**This is very commonly asked in interviews:**

**“How do you use -detailed-exitcode in pipelines?”**

- You can now answer: “We capture the exit code in CI; 0 means no changes, 2 means changes (trigger approval), and 1 means failure (stop pipeline).”

Great clarification — this is where interviewers try to trip people up.

When you run `terraform plan -detailed-exitcode`, the **exit code is about the proposed infrastructure changes** Terraform calculates by comparing:

- **Terraform config (HCL code)**
- **Terraform state (memory of what was last applied)**
- **Real infrastructure (cloud resources, after refresh)**

### Exit Code Meaning in Context

- **0 → Success, No Changes**

  - Terraform compared config vs state vs real infra and found them all in sync.
  - Means: “Your infra is already exactly as described in code. Nothing to add, change, or destroy.”
  - In CI: You can allow auto-merge because config matches reality.

- **2 → Success, but Changes Present**

  - Terraform found a difference between code vs state/infra.
  - Could be:

    - You edited code (e.g., new EC2 instance, updated tags).
    - Or infra drifted (manual console changes).

  - In CI: This signals a PR _will_ change infra if applied → block or require approval.

- **1 → Error**

  - Terraform failed to run plan (syntax error, provider error, auth issue, etc.).
  - In CI: Pipeline fails immediately.

#### **`terraform fmt -check -recursive`**

- Ensures code is properly formatted.
- Returns non-zero if any file isn’t formatted → great for enforcing style in CI.
