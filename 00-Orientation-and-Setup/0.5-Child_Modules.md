# 0.4 — Child Modules (Reusable Components)

## Purpose of Child Modules

**Encapsulation**

- A child module hides the implementation details of resources.
- You only expose **inputs (variables)** and **outputs**, so consumers don’t care how it’s built.
- Example: You just ask for a VPC with a CIDR — the module internally wires subnets, IGWs, route tables.

**Reusability**

- Instead of repeating the same resource definitions across projects, you package them once and reuse.
- Promotes **DRY (Don’t Repeat Yourself)** and consistency.
- Example: Same “EC2 with security group” module can be used for dev, staging, and prod with different variable values.

Short answer you can give in interviews:
_“Child modules allow us to encapsulate infrastructure logic and make it reusable across projects. This means cleaner code, consistency, and easier maintenance.”_

## Common File Split in a Terraform Module

- **`main.tf`** → Core logic (the actual resources).
  _Think: “What this module does.”_

- **`variables.tf`** → Input variables with type, default, description.
  _Think: “What knobs the user can turn.”_

- **`outputs.tf`** → Export values (IDs, ARNs, IPs) for use in other modules.
  _Think: “What results the module gives back.”_

- **`versions.tf`** → Constraints for Terraform CLI and providers.
  _Think: “Compatibility rules.”_

- **`README.md`** → Documentation on usage (inputs, outputs, examples).
  _Think: “How others will know what this module is for.”_

- **`examples/`** → Sample configs showing correct usage.
  _Think: “Working demo for copy-paste.”_

### Best Practices for Terraform Modules

1. **Keep modules generic (no hardcoding)**

   - Don’t bake in project-specific names, IDs, or regions.
   - Example (bad):

     ```hcl
     resource "aws_s3_bucket" "this" {
       bucket = "faizan-personal-backup"
     }
     ```

     Example (good):

     ```hcl
     resource "aws_s3_bucket" "this" {
       bucket = var.bucket_name
     }
     ```

---

2. **Pass variables from root**

   - Modules should **accept values** (region, tags, CIDR, etc.) instead of deciding them.
   - This makes them reusable in **dev, staging, prod** just by changing inputs.
   - Example root usage:

     ```hcl
     module "vpc" {
       source     = "./modules/vpc"
       cidr_block = var.vpc_cidr
     }
     ```

---

3. **Use outputs for clean interfaces**

   - Modules should return important values (like IDs, ARNs, IPs) so other modules can chain them.
   - Example:

     ```hcl
     output "vpc_id" {
       value = aws_vpc.this.id
     }
     ```

   - Root module can then do:

     ```hcl
     subnet_vpc_id = module.vpc.vpc_id
     ```

👉 Interview answer in one line:
_“Good Terraform modules are generic, accept inputs via variables, and expose clean outputs so they can be reused across environments.”_

## Registry & versioning (public or private)

Here’s the breakdown in simple, interview-friendly terms:

---

## Module Registries & Versioning

### 1. **Terraform Registry (public)**

- Hosted by HashiCorp at [registry.terraform.io](https://registry.terraform.io).
- Free, open catalog of modules and providers.
- Example: instead of writing your own VPC module, you can use `terraform-aws-modules/vpc/aws`.

---

### 2. **Private Registry**

- Many companies don’t want to rely on public registry for security or customization.
- Private registries can be:

  - **Terraform Cloud/Enterprise** (built-in private module registry).
  - Or custom (e.g., hosting modules in GitHub/GitLab and referencing via `source`).

---

### 3. **Versioning**

- Always **pin module versions** to avoid breaking changes.
- Example:

  ```hcl
  module "vpc" {
    source  = "terraform-aws-modules/vpc/aws"
    version = "3.19.0"
  }
  ```

- Use **semantic versioning** (`~>`, `>=`, `<=`) for flexibility with control:

  - `~> 3.0` → Any version `>= 3.0.0` and `< 4.0.0` (safe minor upgrades).
  - Exact pinning (`= 3.19.0`) when you need reproducibility.

---

### Interview Hook

If they ask _“How do you manage modules at scale?”_ →

- _“We publish common infra modules (VPC, IAM, EKS, S3) into a private registry and enforce version pinning with semantic versioning to keep builds stable.”_
